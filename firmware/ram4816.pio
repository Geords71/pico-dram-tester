; hm4816 (and mb8118, mcm4517, [d|m]2118) Test Program

; Pin Assignments
; SP0  = A0
; SP1  = A1
; SP2  = A2
; SP3  = A3
; SP4  = A4
; SP5  = A5
; SP6  = A6
; SP7  = nc
; SP8  = nc
; SP9  = D
; SP10 = WE#
; SP11 = RAS#
; SP12 = CAS#
; SP13 = nc
; SP14 = nc
; SP15 = nc
; SP16 = Q

; Timing values (nameplate, tRAC): 100ns, 120ns, 150ns, 200ns
; set pins: CAS, RAS, WR.
; Note: We need to update the address lines and the RAS# at the same time.

.pio_version 0
.program ram4816
jmp begin

; the delays here are not your normal clock cycles. They are an index into
; the fields in your selected xxxx_delays[] line. So for 100ns delays,
; 2 = 20 cycles?

full_transfer:
    nop [1]               ;        [0]  ES44
    nop [2]               ; 264.0  [26] tRC = 260.7ns
    out pins, 8           ; 3.3         Load row address
    set pins, 0b101       ; 6.6         Lower RAS#
    nop [3]               ; 26.4   [5]  tRCD (RAS to CAS) = 26.4ns

cas_only_transfer:
    out pins, 10          ; 29.7        Load col address + write data
    jmp !x skip_wr        ; 33
    set pins, 0b000       ; 36.3        Lower CAS#, WR#
    jmp skip_wr2          ; 39.6

skip_wr:
    set pins, 0b001       ; 36.3        Lower CAS#
    nop                   ; 39.6

skip_wr2:
    mov OSR, NULL         ; 42.9        Clear OSR  ES 8cyc+[3]=2=10
    nop [4]               ; 56.1   [3]  ES 10+[4]=14
    set pins, 0b001       ; 59.4        Raise WR#  tWCH = 26.4ns. ES1+14=15
    out pins, 10          ; 62.7        Clear addr+data. tCAH, tDH = 29.7ns. ES1+15=16
    nop [5]               ; 108.9  [13] total = tRSH, tRSH ES 16+[5]=23
    in pins, 1            ; 112.2       Get bit tCAC = 75.9ns ES 24
    set pins, 0b101       ; 115.5       Raise CAS#. tCAS = 79.2ns ES 25
    push noblock          ; 118.8       ES 26
    nop [6]               ; 151.8  [9]  ES27+[6]=37
    jmp !y begin          ; 155.1       Raise RAS# only if we are doing a full transfer ES38
    jmp skip_ras          ; 158.4

begin:
    set pins, 0b111       ; 158.4       Raise RAS#. tRAS=151.8ns  ES39.  = 3.3*37=122.1ns

skip_ras:
    pull block            ; 161.7       Wait for new data to arrive ES40
    out y, 1              ; 165.0       Get first bit which tells us if this is fast page mode ES41
    out x, 1              ; 168.3       Get second bit which tells us if we are in write mode. ES42
    jmp !y full_transfer  ; 171.6       ES43
    out NULL, 8 [7]       ; 174.9       Throw out row address
    jmp cas_only_transfer ; 178.2       Fast page mode tCP=22*3.3=72.6ns


% c-sdk {
// Original delay numbers are 27, 5, 3, 13, 9
#include "constants.h"
#define RAM4816_DELAY_FIELDS 8
#define RAM4816_DELAYS 4

static const uint8_t ram4816_delays[RAM4816_DELAYS][RAM4816_DELAY_FIELDS] = {
    {0, 0,  20, 2,  2,  6,  5,  0}, // 100ns
    {0, 0,  25, 2,  4,  7,  8,  0}, // 120ns
    {0, 0,  25, 2,  6, 10, 12,  0}, // 150ns
    {0, 11, 20, 7, 13, 21,  4,  9}  // 200ns
};

static inline void ram4816_program_init(PIO pio, uint sm, uint offset) {
    uint count;

    // Set up pins.
    for (count = 0; count < TOTAL_PIN_COUNT; count++) {
        pio_gpio_init(pio, BASE_PIN + count);
        gpio_set_slew_rate(BASE_PIN + count, GPIO_SLEW_RATE_FAST);
        gpio_set_drive_strength(BASE_PIN + count, GPIO_DRIVE_STRENGTH_4MA);
    }

    pio_sm_set_consecutive_pindirs(pio, sm, OUTPUT_BASE_PIN, OUTPUT_PIN_COUNT, true); // true=output
    pio_sm_set_consecutive_pindirs(pio, sm, INPUT_BASE_PIN, INPUT_PIN_COUNT, false); // false=input

    pio_sm_set_clkdiv(pio, sm, 1); // should just be the default.

    pio_sm_config c = ram4816_program_get_default_config(offset);

    // A0, A1, A2, A3, A4, A5, A6, nc, nc, D, WR, RAS, CAS, nc, nc, nc, IN
    sm_config_set_out_pins(&c, BASE_PIN, 10);
    sm_config_set_set_pins(&c, BASE_PIN + 10, 3); // Max is 5.
    sm_config_set_in_pins(&c, BASE_PIN + 16);

    // Shift right, Autopull off, 20 bits (1 + 1 + 8 + 10) at a time
    sm_config_set_out_shift(&c, true, false, 20);
    
    // Shift left, Autopull on, 1 bit
    sm_config_set_in_shift(&c, false, false, 1);

    // hw_set_bits(&pio->input_sync_bypass, 1u << pin); // To bypass synchronization on an input
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Routines for reading and writing memory through the FIFOs
int ram4816_ram_read(int addr)
{
    uint d;

    // Send a 32 bit data value in this bit format: ...D0CCCCCCCCRRRRRRRRWF
    pio_sm_put(pio, sm, 
        0                    | // ...0000000000000000000F Add fast page mode flag
        0 << 1               | // ...000000000000000000WF Add write flag
        (addr & 0x007f) << 2 | // ...0000000000RRRRRRRRWF Add row address
        (addr & 0x7f00) << 2 | // ...00CCCCCCCCRRRRRRRRWF Add column address
        ((0 & 1) << 19));      // ...D0CCCCCCCCRRRRRRRRWF Add data bit

    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for data to arrive
    d = pio_sm_get(pio, sm);                    // Return the data

    //gpio_put(GPIO_LED, d);
    return d;
}

void ram4816_ram_write(int addr, int data)
{
    pio_sm_put(pio, sm, 
        0                    | // ...0000000000000000000F Add fast page mode flag
        1 << 1               | // ...000000000000000000WF Add write flag
        (addr & 0x007f) << 2 | // ...0000000000RRRRRRRRWF Add row address
        (addr & 0x7f00) << 2 | // ...00CCCCCCCCRRRRRRRRWF Add column address
        ((data & 1) << 19));   // ...D0CCCCCCCCRRRRRRRRWF Add data bit

    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for dummy data
    pio_sm_get(pio, sm);                        // Discard the dummy data bit
}

// Routines to set up and tear down the PIO program (and the RAM test)
void ram4816_setup_pio(uint speed_grade, uint variant)
{
    // From patcher.c. Stash the program structure and its instructions.
    // for future global use? ram4816_program is a convention variable.
    set_current_pio_program(&ram4816_program); 

    // Patch the program with the correct delay values. This will replace the
    // standard cycle mutiple with an index into a list of custom values.
    pio_patch_delays(ram4816_delays[speed_grade], RAM4816_DELAY_FIELDS); // from patcher.c

    bool rc = pio_claim_free_sm_and_add_program_for_gpio_range(
        get_current_pio_program(), // Yank the program structure that we stashed
        &pio,                      // Return the claimed PIO Block
        &sm,                       // Return the claimed state machine
        &offset,                   // Return the instruction list offset
        BASE_PIN,                  // The first GPIO pin we will claim
        TOTAL_PIN_COUNT,           // How many sequential pins we want
        true                       // Claim pins exclusively?
    );

    ram4816_program_init(pio, sm, offset);

    pio_sm_set_enabled(pio, sm, true);
}

void ram4816_teardown_pio()
{
    pio_sm_set_enabled(pio, sm, false);
    pio_remove_program_and_unclaim_sm(&ram4816_program, pio, sm, offset);
}

// This RAM chip configuration
static const mem_chip_t ram4816_chip = {
    .setup_pio = ram4816_setup_pio,
    .teardown_pio = ram4816_teardown_pio,
    .ram_read = ram4816_ram_read,
    .ram_write = ram4816_ram_write,
    .mem_size = 16384,
    .bits = 1,
    .speed_grades = RAM4816_DELAYS,
    .chip_name = "4816 (16Kx1 - 4164 socket)",
    .speed_names = {"100ns", "120ns", "150ns", "200ns"}
};

%}
